-- Version 6b
-- Updates:
-- Removed Active Checker due to performance degration
-- Added ClearTextOnFocus option for Inputbox

local UIS = game:GetService('UserInputService')
local TextService = game:GetService('TextService');
local CoreGui = game:GetService('CoreGui')
local RunService = game:GetService('RunService')
local RenderStepped = RunService.RenderStepped
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local ProtectGui = protectgui or (syn and syn.protect_gui) or (function() end)

local ScreenGui = Instance.new('ScreenGui')
ProtectGui(ScreenGui);

ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
ScreenGui.Parent = CoreGui

local Toggles = {};
local Options = {};

getgenv().Toggles = Toggles;
getgenv().Options = Options;

local Library = {
    Registry = {},
    RegistryMap = {},

    RainbowAccent = false,
    OutlineColor = Color3.fromRGB(50,50,50),
    AccentColor = Color3.fromRGB(0,85,255),
    MainColor = Color3.fromRGB(28,28,28),
    BackgroundColor = Color3.fromRGB(20,20,20),
    FontColor = Color3.fromRGB(255,255,255),
    Black = Color3.fromRGB(0,0,0),
    White = Color3.fromRGB(255,255,255),

    OpenedFrames = {},

    Signals = {},
    ScreenGui = ScreenGui,
}

task.spawn(function()
    local Tick = tick()

    local Hue = 0


    while game:GetService('RunService').RenderStepped:Wait() do 
        if tick() - Tick >= (1/60)  then 

            Hue = Hue + (1/400) 

            if Hue >= 1 then 
                Hue = 0 
            end

            Library.RainbowAccentColor = Color3.fromHSV(Hue, 0.8, 1) 

            Tick = tick()
        end	
    end
end)

function Library:GetDarkerColor(Color)
    local H, S, V = Color3.toHSV(Color)
    return Color3.fromHSV(H, S, V / 1.5)
end Library.DarkerAccentColor = Library:GetDarkerColor(Library.AccentColor)

function GetAccentColor()
    return Library.RainbowAccent and Library['RainbowAccentColor'] or Library['AccentColor']
end

function Library:AttemptSave()
    if Library.SaveManager then
        --Library.SaveManager:Save();
    end;
end

function Library:Create(Class, Properties)
    local _Instance = Class

    if type(Class) == 'string' then
        _Instance = Instance.new(Class)
    end

    for Property, Value in next, Properties do
        _Instance[Property] = Value
    end

    return _Instance
end

function Library:CreateLabel(Properties)
    local Instance = Library:Create('TextLabel', {
        BackgroundTransparency = 1,
        Font = Enum.Font.Code,
        TextColor3 = Library.FontColor,
        TextSize = 16,
        TextStrokeTransparency = 0,
    })

    Library:AddToRegistry(Instance, {
        TextColor3 = 'FontColor'
    })

    return Library:Create(Instance, Properties)
end

function Library:MakeDraggable (Instance, Cutoff)
    Instance.InputBegan:Connect(function(Input)
        if Input.UserInputType == Enum.UserInputType.MouseButton1 then
            local OrgPos = Vector2.new(
                Mouse.X - Instance.AbsolutePosition.X,
                Mouse.Y - Instance.AbsolutePosition.Y
            )

            if OrgPos.Y > (Cutoff or 40) then
                return
            end

            local OrgAnc_X = Instance.Size.X.Offset * Instance.AnchorPoint.X
            local OrgAnc_Y = Instance.Size.Y.Offset * Instance.AnchorPoint.Y

            while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do

                Instance.Position = UDim2.new(
                    0,
                    Mouse.X - OrgPos.X + OrgAnc_X,
                    0,
                    Mouse.Y - OrgPos.Y + OrgAnc_Y
                )

                RenderStepped:Wait()
            end
            if Instance.AbsolutePosition.Y <= -58  then
                Instance.Position = UDim2.new(Instance.Position.X.Scale, Instance.Position.X.Offset , Instance.Position.Y.Scale, Instance.Position.Y.Offset + 30)
            end
        end
    end)
end

function Library:OnHighlight(HighlightInstance, Instance, Properties, PropertiesDefault)
    HighlightInstance.MouseEnter:Connect(function()
        local Reg = Library.RegistryMap[Instance]

        for Property, ColorIdx in next, Properties do
            Instance[Property] = ColorIdx == 'AccentColor' and GetAccentColor() or ColorIdx == 'DarkerAccentColor' and Library:GetDarkerColor(GetAccentColor()) or Library[ColorIdx] or ColorIdx

            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx
            end
        end
    end)

    HighlightInstance.MouseLeave:Connect(function()
        local Reg = Library.RegistryMap[Instance]

        for Property, ColorIdx in next, PropertiesDefault do
            Instance[Property] = ColorIdx == 'AccentColor' and GetAccentColor() or ColorIdx == 'DarkerAccentColor' and Library:GetDarkerColor(GetAccentColor()) or Library[ColorIdx] or ColorIdx

            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx
            end
        end
    end)
end

function Library:MouseIsOverOpenedFrame()
    for Frame, _ in next, Library.OpenedFrames do
        local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize

        if Mouse.X >= AbsPos.X and Mouse.X <= AbsPos.X + AbsSize.X
            and Mouse.Y >= AbsPos.Y and Mouse.Y <= AbsPos.Y + AbsSize.Y then

            return true
        end
    end;
end;

function Library:MapValue(Value, MinA, MaxA, MinB, MaxB)
    return (1 - ((Value - MinA) / (MaxA - MinA))) * MinB + ((Value - MinA) / (MaxA - MinA)) * MaxB
end

function Library:GetTextBounds(Text, Font, Size)
    local TextBounds = TextService:GetTextSize(Text, Size, Font, Vector2.new(1920, 1080))
    return TextBounds.X, TextBounds.Y
end

function Library:AddToRegistry(Instance, Properties)
    local Idx = #Library.Registry + 1
    local Data = {
        Instance = Instance,
        Properties = Properties,
        Idx = Idx,
    }

    table.insert(Library.Registry, Data)
    Library.RegistryMap[Instance] = Data
end

function Library:RemoveFromRegistry(Instance)
    local Data = Library.RegistryMap[Instance]

    if Data then
        for Idx = #Library.Registry, 1, -1 do
            if Library.Registry[Idx] == Data then
                table.remove(Library.Registry, Idx)
            end
        end

        Library.RegistryMap[Instance] = nil
    end
end

function Library:UpdateColorsUsingRegistry()
    -- TODO: Could have an 'active' list of objects
    -- where the active list only contains Visible objects.

    -- IMPL: Could setup .Changed events on the AddToRegistry function
    -- that listens for the 'Visible' propert being changed.
    -- Visible: true => Add to active list, and call UpdateColors function
    -- Visible: false => Remove from active list.

    -- The above would be especially efficient for a rainbow menu color or live color-changing.

    for Idx, Object in next, Library.Registry do
        for Property, ColorIdx in next, Object.Properties do
            if type(ColorIdx) == 'string' then
                Object.Instance[Property] = ColorIdx == 'AccentColor' and GetAccentColor() or ColorIdx == 'DarkerAccentColor' and Library:GetDarkerColor(GetAccentColor()) or Library[ColorIdx]
            elseif type(ColorIdx) == 'function' then
                Object.Instance[Property] = ColorIdx()
            end
        end
    end
end

function Library:GiveSignal(Signal)
    -- Only used for signals not attached to library instances, as those should be cleaned up on object destruction by Roblox
    table.insert(Library.Signals, Signal)
end

function Library:Unload()
    -- Unload all of the signals
    for Idx = #Library.Signals, 1, -1 do
        local Connection = table.remove(Library.Signals, Idx)
        Connection:Disconnect()
    end

    -- Call our unload callback, maybe to undo some hooks etc
    if Library.OnUnload then
        Library.OnUnload()
    end

    ScreenGui:Destroy()
end

function Library:OnUnload(Callback)
    Library.OnUnload = Callback
end

Library:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)
    if Library.RegistryMap[Instance] then
        Library:RemoveFromRegistry(Instance);
    end;
end))

local BaseAddons = {}

do
    local Funcs = {}

    function Funcs:AddTooltip(Str)
        assert(self.HoverRegion, 'Tooltip is missing assigned Hover Region.')

        local Component = self
        local HoverRegion = Component.HoverRegion
        local X,Y = Library:GetTextBounds(Str, Enum.Font.Code, 14)

        local Tooltip = Library:Create('Frame', {
            BackgroundColor3 = Library.Black,
            BorderColor3 = Library.OutlineColor,
            BackgroundTransparency = 0.25,
            Size = UDim2.new(0, X + 5, 0, Y + 2), --
            ZIndex = 11,
            Parent = ScreenGui,
            Visible = false,
        })

        Library:AddToRegistry(Tooltip, {
            BorderColor3 = 'OutlineColor',
        })

        local Label = Library:CreateLabel({   
            Size = UDim2.new(0, X, 0, Y), --
            Position = UDim2.new(0, 3, 0, 1), --
            Text = Str,
            TextSize = 14,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 11,
            Parent = Tooltip,
        })

        local Hovering = false
        HoverRegion.MouseEnter:connect(function()
            Hovering = true
            Tooltip.Visible = not Library:MouseIsOverOpenedFrame() and Library.Window.Visible

            while Hovering do
                RunService.Heartbeat:Wait()
                if not Library:MouseIsOverOpenedFrame() and Library.Window.Visible then
                    if Hovering then
                        Tooltip.Visible = true
                        Tooltip.Position = UDim2.new(0, Mouse.X + 15, 0, Mouse.Y)
                    end
                else
                    Tooltip.Visible = false
                end
            end
        end)

        HoverRegion.MouseLeave:connect(function()
            Hovering = false
            Tooltip.Visible = false
        end)
    end

    function Funcs:AddKeyPicker(Idx, Info)
        local ParentObj = self
        local AddonRegion = self.AddonRegion
        local Container = self.Container

        if #AddonRegion:GetChildren() > 2 then print(Idx, 'Already reached the max of 2 Addons') return end

        local KeyPicker = {
            Value = Info.Default,
            Toggled = false,
            Held = false,
            Mode = Info.Mode or 'Toggle',         -- Hold or Toggle
            Type = 'KeyPicker',

            NoUI = Info.NoUI or false,
            SyncToggleState = Info.SyncToggleState or false,
        }

        if KeyPicker.SyncToggleState then
            KeyPicker.Mode = 'Toggle'
        end

        local PickerOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black,
            Size = UDim2.fromOffset(28, 14),
            ZIndex = 6,
            Parent = AddonRegion,
        })

        local PickerInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor,
            BorderColor3 = Library.OutlineColor,
            BorderMode = Enum.BorderMode.Inset,
            Size = UDim2.fromScale(1, 1),
            ZIndex = 7,
            Parent = PickerOuter,
        })

        Library:AddToRegistry(PickerInner, {
            BackgroundColor3 = 'BackgroundColor';
            BorderColor3 = 'OutlineColor';
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.fromScale(1, 1);
            TextSize = 13;
            Text = KeyPicker.Value;
            TextWrapped = true;
            ZIndex = 8;
            Parent = PickerInner;
        })

        local ContainerLabel = Library:CreateLabel({
            TextXAlignment = Enum.TextXAlignment.Left;
            Size = UDim2.new(1, 0, 0, 18);
            TextSize = 13;
            Visible = false;
            ZIndex = 110;
            Parent = Library.KeybindContainer;
        });

        local function GetInputKey(Input)
            local Key
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                Key = "MB1"
            elseif Input.UserInputType == Enum.UserInputType.MouseButton2 then 
                Key = "MB2"
            elseif Input.UserInputType == Enum.UserInputType.Keyboard then
                Key = Input.KeyCode.Name
            end
            return Key
        end

        function KeyPicker:Update()
            if KeyPicker.NoUI then return end

            local State = KeyPicker:GetState()

            ContainerLabel.Text = string.format('[%s] %s (%s)', KeyPicker.Value, Info.Text, KeyPicker.Mode)

            ContainerLabel.Visible = true;
            ContainerLabel.TextColor3 = State and Library.AccentColor or Library.FontColor;

            Library.RegistryMap[ContainerLabel].Properties.TextColor3 = State and 'AccentColor' or 'FontColor';

            local YSize = 0
            local XSize = 0

            for _, Label in next, Library.KeybindContainer:GetChildren() do
                if Label:IsA('TextLabel') and Label.Visible then
                    YSize = YSize + 18;
                    if (Label.TextBounds.X > XSize) then
                        XSize = Label.TextBounds.X 
                    end 
                end;
            end;

            Library.KeybindFrame.Size = UDim2.new(0, math.max(XSize + 10, 210), 0, YSize + 23)
        end

        function KeyPicker:SetValue(Info)
            local Key, Mode = Info['Key'], Info['Mode'] or KeyPicker.Mode
            KeyPicker.Value = Key
            KeyPicker.Mode = Mode
            KeyPicker:Update()
            DisplayLabel.Text = Key
        end

        function KeyPicker:GetState()
            if KeyPicker.Mode == 'Hold' then
                return KeyPicker.Held
            else
                return KeyPicker.Toggled;
            end;
        end;

        if ParentObj.Type == 'Toggle' and KeyPicker.SyncToggleState then
            ParentObj:KeybindOnChanged(function(State) 
                KeyPicker.Toggled = State 
                KeyPicker:Update() 
            end)
        end

        function KeyPicker:OnClick(Callback)
            KeyPicker.Clicked = Callback
        end

        function KeyPicker:OnHeldChanged(Callback)
            KeyPicker.HeldChanged = Callback
        end

        function KeyPicker:DoClick(State)
            if ParentObj.Type == 'Toggle' and KeyPicker.SyncToggleState then
                ParentObj:SetValue(State)
            end

            if KeyPicker.Clicked then
                KeyPicker.Clicked(State)
            end
        end

        function KeyPicker:HeldChange(State)
            if KeyPicker.HeldChanged then
                KeyPicker.HeldChanged(State)
            end
        end

        local Picking = false

        PickerOuter.InputBegan:Connect(function(Input)
            if not Picking and Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                Picking = true;

                DisplayLabel.Text = '';

                local Break;
                local Text = '';

                task.spawn(function()
                    while (not Break) do
                        if Text == '...' then
                            Text = '';
                        end;

                        Text = Text .. '.';
                        DisplayLabel.Text = Text;

                        wait(0.4);
                    end;
                end);

                wait(0.2);

                local Event;
                Event = UIS.InputBegan:Connect(function(Input)
                    local Key = GetInputKey(Input)

                    Break = true;
                    Picking = false;

                    DisplayLabel.Text = Key;
                    KeyPicker.Value = Key;

                    KeyPicker:Update()
                    Library:AttemptSave();

                    Event:Disconnect();
                end);
            end;
        end);
        KeyPicker:Update()

        Library:GiveSignal(UIS.InputBegan:Connect(function(Input, Processed)
            if not Processed and not Picking then
                local Key = GetInputKey(Input)
                if Key == KeyPicker.Value then
                    if KeyPicker.Mode == "Hold" then
                        KeyPicker.Held = true
                        KeyPicker:Update()
                        KeyPicker:HeldChange(true)
                    else
                        KeyPicker.Toggled = not KeyPicker.Toggled
                        KeyPicker:DoClick(KeyPicker.Toggled)
                        KeyPicker:Update()
                    end
                end
            end
        end))

        Library:GiveSignal(UIS.InputEnded:Connect(function(Input, Processed)
            if KeyPicker.Mode == "Hold" then
                local Key = GetInputKey(Input)
                if Key == KeyPicker.Value then
                    KeyPicker.Held = false
                    KeyPicker:Update()
                    KeyPicker:HeldChange(false)
                end
            end
        end))

        Options[Idx] = KeyPicker

        return KeyPicker
    end

    function Funcs:AddColorPicker(Idx, Info)
        local AddonRegion = self.AddonRegion;
        local Container = self.Container;

        if #AddonRegion:GetChildren() > 2 then print(Idx, 'Already reached the max of 2 Addons') return end

        local ColorPicker = {
            Value = Info.Default;
            Type = 'ColorPicker';
            Title = type(Info.Title) == 'string' and Info.Title or 'Color picker',
        };

        function ColorPicker:SetHSVFromRGB(Color)
            local H, S, V = Color3.toHSV(Color);

            ColorPicker.Hue = H;
            ColorPicker.Sat = S;
            ColorPicker.Vib = V;
        end;

        ColorPicker:SetHSVFromRGB(ColorPicker.Value);

        local DisplayFrame = Library:Create('Frame', {
            BackgroundColor3 = ColorPicker.Value;
            BorderColor3 = Library:GetDarkerColor(ColorPicker.Value);
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(0, 28, 0, 14);
            ZIndex = 6;
            Parent = AddonRegion;
        });

        local RelativeOffset = 0;

        for _, Element in next, Container:GetChildren() do
            if not Element:IsA('UIListLayout') then
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            end;
        end;

        local PickerFrameOuter = Library:Create('Frame', {
            Name = 'Color';
            BackgroundColor3 = Library.White;
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 1, 0, 20 + RelativeOffset + 1);
            Size = UDim2.new(0, 223, 0, 244);
            Visible = false;
            ZIndex = 15;
            Parent = Container.Parent;
        });

        local PickerFrameInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 16;
            Parent = PickerFrameOuter;
        });

        local Highlight = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 0, 2);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local SatVibMapOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 5, 0, 25);
            Size = UDim2.new(0, 185, 0, 185);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local SatVibMapInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Parent = SatVibMapOuter;
        });

        local SatVibMap = Library:Create('ImageLabel', {
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Image = 'rbxassetid://4155801252';
            Parent = SatVibMapInner;
        });

        local SatMapReticle = Library:Create('ImageLabel', {
            AnchorPoint = Vector2.new(0.5, 0.5),
            BackgroundColor3 = Library.White,
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 20, 0, 20),
            Image = "http://www.roblox.com/asset/?id=9628117279",
            ZIndex = 19;
            Parent = SatVibMap;
        });

        local HueSelectorOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 196, 0, 25);
            Size = UDim2.new(0, 15, 0, 185);
            ZIndex = 17;
            Parent = PickerFrameInner;
        });

        local HueSelectorInner = Library:Create('Frame', {
            BackgroundColor3 = Color3.new(1, 1, 1);
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18;
            Parent = HueSelectorOuter;
        });

        local HueReticle = Library:Create('Frame', {
            BackgroundColor3 = Library.White,
            BorderColor3 = Library.Black,
            Position = UDim2.new(1, -6, 0, 0),
            Size = UDim2.new(0, 6, 0, 1),
            ZIndex = 19;
            Parent = HueSelectorInner;
        });

        local HueTextSize = Library:GetTextBounds('Hex color', Enum.Font.Code, 16) + 3
        local RgbTextSize = Library:GetTextBounds('255, 255, 255', Enum.Font.Code, 16) + 3

        local HueBoxOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.fromOffset(5, 217),
            Size = UDim2.new(0.5, -7.5, 0, 20),
            ZIndex = 18,
            Parent = PickerFrameInner;
        });

        local HueBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 18,
            Parent = HueBoxOuter;
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = HueBoxInner;
        });

        local HueBox = Library:Create('TextBox', {
            BackgroundTransparency = 1;
            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -5, 1, 0);
            Font = Enum.Font.Code;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = 'Hex color',
            Text = '#FFFFFF',
            TextColor3 = Library.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 20,
            Parent = HueBoxInner;
        });

        local RgbBoxBase = Library:Create(HueBoxOuter:Clone(), {
            Position = UDim2.new(0.5, 2, 0, 217),
            Size = UDim2.new(0.5, -7.5, 0, 20),
            Parent = PickerFrameInner
        })  

        local RgbBox = Library:Create(RgbBoxBase.Frame:FindFirstChild('TextBox'), {
            Text = '255, 255, 255',
            PlaceholderText = 'RGB color',
            TextColor3 = Library.FontColor,
        })

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 0, 14);
            Position = UDim2.fromOffset(5, 5);
            TextXAlignment = Enum.TextXAlignment.Left;
            TextSize = 14;
            Text = ColorPicker.Title,--Info.Default;
            TextWrapped = false;
            ZIndex = 16;
            Parent = PickerFrameInner;
        });


        Library:AddToRegistry(PickerFrameInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(Highlight, { BackgroundColor3 = 'AccentColor'; });
        Library:AddToRegistry(SatVibMapInner, { BackgroundColor3 = 'BackgroundColor'; BorderColor3 = 'OutlineColor'; });

        Library:AddToRegistry(HueBoxInner, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBoxBase.Frame, { BackgroundColor3 = 'MainColor'; BorderColor3 = 'OutlineColor'; });
        Library:AddToRegistry(RgbBox, { TextColor3 = 'FontColor', });
        Library:AddToRegistry(HueBox, { TextColor3 = 'FontColor', });

        local SequenceTable = {};

        for Hue = 0, 1, 0.1 do
            table.insert(SequenceTable, ColorSequenceKeypoint.new(Hue, Color3.fromHSV(Hue, 1, 1)));
        end;

        local HueSelectorGradient = Library:Create('UIGradient', {
            Color = ColorSequence.new(SequenceTable);
            Rotation = 90;
            Parent = HueSelectorInner;
        });

        HueBox.FocusLost:Connect(function(enter)
            if enter then
                local success, result = pcall(Color3.fromHex, HueBox.Text)
                if success and typeof(result) == 'Color3' then
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(result)
                end
            end

            ColorPicker:Display()
        end)

        RgbBox.FocusLost:Connect(function(enter)
            if enter then
                local r, g, b = RgbBox.Text:match('(%d+),%s*(%d+),%s*(%d+)')
                if r and g and b then
                    ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(Color3.fromRGB(r, g, b))
                end
            end

            ColorPicker:Display()
        end)

        function ColorPicker:Display()
            ColorPicker.Value = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib);
            SatVibMap.BackgroundColor3 = Color3.fromHSV(ColorPicker.Hue, 1, 1);

            Library:Create(DisplayFrame, {
                BackgroundColor3 = ColorPicker.Value;
                BorderColor3 = Library:GetDarkerColor(ColorPicker.Value);
            });

            SatMapReticle.Position = UDim2.new(ColorPicker.Sat ,0, math.clamp(-(ColorPicker.Vib - 1), 0, 1),0)
            HueReticle.Position = UDim2.new(1, -6, ColorPicker.Hue, 0)

            HueBox.Text = '#' .. ColorPicker.Value:ToHex():upper()
            RgbBox.Text = table.concat({ math.floor(ColorPicker.Value.R * 255), math.floor(ColorPicker.Value.G * 255), math.floor(ColorPicker.Value.B * 255) }, ', ')

            if ColorPicker.Changed then
                ColorPicker.Changed(ColorPicker.Value)
            end;
        end;

        function ColorPicker:OnChanged(Func)
            ColorPicker.Changed = Func;
            Func(ColorPicker.Value)
        end;

        function ColorPicker:Show()
            for Frame, Val in next, Library.OpenedFrames do
                if Frame.Name == 'Color' then
                    Frame.Visible = false;
                    Library.OpenedFrames[Frame] = nil;
                end;
            end;

            PickerFrameOuter.Visible = true;
            Library.OpenedFrames[PickerFrameOuter] = true;
        end;

        function ColorPicker:Hide()
            PickerFrameOuter.Visible = false;
            Library.OpenedFrames[PickerFrameOuter] = nil;
        end;

        function ColorPicker:SetValue(HSV)
            local Color = Color3.fromHSV(HSV[1], HSV[2], HSV[3]);

            ColorPicker:SetHSVFromRGB(Color);
            ColorPicker:Display();
        end;

        function ColorPicker:SetValueRGB(Color)
            ColorPicker:SetHSVFromRGB(Color);
            ColorPicker:Display();
        end;

        SatVibMap.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    local MinX = SatVibMap.AbsolutePosition.X;
                    local MaxX = MinX + SatVibMap.AbsoluteSize.X;
                    local MouseX = math.clamp(Mouse.X, MinX, MaxX);

                    local MinY = SatVibMap.AbsolutePosition.Y;
                    local MaxY = MinY + SatVibMap.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Sat = (MouseX - MinX) / (MaxX - MinX);
                    ColorPicker.Vib = 1 - ((MouseY - MinY) / (MaxY - MinY));
                    ColorPicker:Display();

                    RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        HueSelectorInner.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    local MinY = HueSelectorInner.AbsolutePosition.Y;
                    local MaxY = MinY + HueSelectorInner.AbsoluteSize.Y;
                    local MouseY = math.clamp(Mouse.Y, MinY, MaxY);

                    ColorPicker.Hue = ((MouseY - MinY) / (MaxY - MinY));
                    ColorPicker:Display();

                    RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        DisplayFrame.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                if PickerFrameOuter.Visible then
                    ColorPicker:Hide();
                else
                    ColorPicker:Show();
                end;
            end;
        end);

        Library:GiveSignal(UIS.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = PickerFrameOuter.AbsolutePosition, PickerFrameOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - 20 - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    ColorPicker:Hide();
                end;
            end;
        end))

        ColorPicker:Display();
        ColorPicker.DisplayFrame = DisplayFrame

        Options[Idx] = ColorPicker;

        return ColorPicker;
    end;
    BaseAddons = Funcs
end

local BaseComponents = {}

do
    local Funcs = {}

    function Funcs:AddBlank(Size)
        local Groupbox = self
        local Container = Groupbox.Container

        Library:Create('Frame', {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, Size),
            ZIndex = 1,
            Parent = Container,
        })
    end

    function Funcs:AddDivider()
        local Groupbox = self
        local Container = Groupbox.Container

        Groupbox:AddBlank(2)
        local DividerOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black,
            Size = UDim2.new(1, -4, 0, 4),
            ZIndex = 5,
            Parent = Container,
        })

        local DividerInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor,
            BorderColor3 = Library.OutlineColor,
            BorderMode = Enum.BorderMode.Inset,
            Size = UDim2.new(1, 0, 1, 0),
            ZIndex = 6,
            Parent = DividerOuter,
        })

        Library:AddToRegistry(DividerInner, {
            BackgroundColor3 = 'BackgroundColor',
            BorderColor3 = 'OutlineColor',
        })

        Groupbox:AddBlank(9)
        Groupbox:Resize()
    end

    function Funcs:AddNamedDivider(Text)
        local NamedDivider = {}

        local Groupbox = self
        local Container = Groupbox.Container

        local X, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14)

        Groupbox:AddBlank(2)
        local DividerOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black,
            Size = UDim2.new(1, -4, 0, 4),
            ZIndex = 5,
            Parent = Container,
        })

        local DividerInner = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor,
            BorderColor3 = Library.OutlineColor,
            BorderMode = Enum.BorderMode.Inset,
            Size = UDim2.new(1, 0, 1, 0),
            ZIndex = 6,
            Parent = DividerOuter,
        })

        Library:AddToRegistry(DividerInner, {
            BackgroundColor3 = 'BackgroundColor',
            BorderColor3 = 'OutlineColor',
        })

        local DividerText = Library:CreateLabel({
            BackgroundTransparency = 0,
            BackgroundColor3 = Library.BackgroundColor,
            BorderSizePixel = 0,
            Size = UDim2.new(0, X + 5, 0, Y),
            AnchorPoint = Vector2.new(0.5, 0),
            Position = UDim2.new(0.5, 0, 0, -6),
            Text = Text,
            TextSize = 14,
            ZIndex = 7,
            Parent = DividerInner,
        })

        Library:AddToRegistry(DividerText, {
            BackgroundColor3 = 'BackgroundColor',
            TextColor3 = 'FontColor',
        })

        function NamedDivider:ChangeText(Text)
            local X, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14)
            DividerText.Size = UDim2.new(0, X + 5, 0, Y)
            DividerText.Text = Text
        end

        Groupbox:AddBlank(9)
        Groupbox:Resize()

        return NamedDivider
    end

    function Funcs:AddLabel(Text, DoesWrap)
        local Label = {}

        local Groupbox = self
        local Container = Groupbox.Container

        local X, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14)

        local TextLabel = Library:CreateLabel({
            Size = UDim2.new(0, X + 8, 0, 15),
            Text = Text,
            TextSize = 14,
            TextWrapped = DoesWrap or false,
            RichText = true,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 5,
            Parent = Container,
        })

        local AddonRegion
        if not DoesWrap then  
            AddonRegion = Library:Create('Frame', {
                BackgroundTransparency = 1,
                Position = UDim2.new(0, Container.AbsoluteSize.X -64, 0, 0),
                Size = UDim2.new(0, 60, 0, 16),
                ZIndex = 8;
                Parent = TextLabel,
            })

            Library:Create('UIListLayout', {
                Padding = UDim.new(0, 4),
                FillDirection = Enum.FillDirection.Horizontal,
                HorizontalAlignment = Enum.HorizontalAlignment.Right,
                SortOrder = Enum.SortOrder.LayoutOrder,
                VerticalAlignment = Enum.VerticalAlignment.Center,
                Parent = AddonRegion,
            })
        else
            local _, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge))
            TextLabel.Size = UDim2.new(1, -4, 0, Y)
        end

        function Label:SetText(Text)
            TextLabel.Text = Text

            if DoesWrap then
                local _, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge))
                TextLabel.Size = UDim2.new(1, -4, 0, Y)
            end

            Groupbox:Resize();
        end

        Label.TextLabel = TextLabel
        Label.Container = Container

        if not DoesWrap then
            Label.AddonRegion = AddonRegion
            Label.HoverRegion = TextLabel
            for i,v in pairs (BaseAddons) do Label[i] = v end
        end

        Groupbox:AddBlank(5)
        Groupbox:Resize()

        return Label
    end

    function Funcs:AddButton(Text, CallBack)
        local Button = {}

        local Groupbox = self
        local Container = Groupbox.Container

        local ButtonOuter = Library:Create('Frame', { 
            BorderColor3 = Library.Black,
            Size = UDim2.new(1, -4, 0, 20),
            ZIndex = 5,
            Parent = Container,
        })

        Library:AddToRegistry(ButtonOuter, {
            BorderColor3 = 'Black',
        })

        local ButtonInner = Library:Create('Frame', { 
            BackgroundColor3 = Library.MainColor,
            BorderColor3 = Library.OutlineColor,
            BorderMode = Enum.BorderMode.Inset,
            Size = UDim2.new(1, 0, 1, 0),
            ZIndex = 6,
            Parent = ButtonOuter,
        })

        Library:AddToRegistry(ButtonInner, {
            BackgroundColor3 = 'MainColor',
            BorderColor3 = 'OutlineColor',
        })

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = ButtonInner;
        });

        local ButtonLabel = Library:CreateLabel({ 
            Size = UDim2.new(1, 0, 1, 0),
            TextSize = 14,
            Text = Text,
            ZIndex = 6;
            Parent = ButtonInner,
        })

        Library:OnHighlight(ButtonOuter, ButtonOuter, 
            {BorderColor3 = 'AccentColor'},
            {BorderColor3 = 'Black'}
        )

        ButtonOuter.InputBegan:connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                CallBack()
            end
        end)

        function Button:AddButton(Text, CallBack)
            local SubButton = {}

            ButtonOuter.Size = UDim2.new(0.5, -2, 0, 20)

            local Outer = ButtonOuter:Clone()
            local Inner = Outer.Frame;
            local Label = Inner:FindFirstChildWhichIsA('TextLabel')

            Outer.Position = UDim2.new(1, 2, 0, 0)
            Outer.Size = UDim2.fromOffset(ButtonOuter.AbsoluteSize.X - 2, ButtonOuter.AbsoluteSize.Y)
            Outer.Parent = ButtonOuter

            Label.Text = Text;

            Library:AddToRegistry(Outer, {
                BorderColor3 = 'Black',
            })

            Library:AddToRegistry(Inner, {
                BackgroundColor3 = 'MainColor';
                BorderColor3 = 'OutlineColor';
            });

            Library:AddToRegistry(Label, {
                TextColor3 = 'FontColor',
            })

            Library:OnHighlight(Outer, Outer,
                { BorderColor3 = 'AccentColor' },
                { BorderColor3 = 'Black' }
            )

            Library:Create('UIGradient', {
                Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
                });

                Rotation = 90;
                Parent = Inner;
            });

            Outer.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                    CallBack();
                end;
            end);

            SubButton.HoverRegion = Outer
            for i,v in pairs (BaseAddons) do SubButton[i] = v end

            return SubButton
        end 

        Groupbox:AddBlank(5);
        Groupbox:Resize();

        Button.HoverRegion = ButtonOuter
        Button.Container = Container
        for i,v in pairs (BaseAddons) do Button[i] = v end

        return Button;
    end

    function Funcs:AddInput(Idx, Info) 
        local Textbox = {
            Value = Info.Default or '';
            Numeric = Info.Numeric or false;
            Finished = Info.Finished or false;
            Type = 'Input';
        };

        local Groupbox = self;
        local Container = Groupbox.Container;

        local InputLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 0, 15);
            TextSize = 14;
            Text = Info.Text;
            TextXAlignment = Enum.TextXAlignment.Left;
            ZIndex = 5;
            Parent = Container;
        });

        Groupbox:AddBlank(1);

        local TextBoxOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black;
            Size = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Parent = Container;
        });

        Library:AddToRegistry(TextBoxOuter, {
            BorderColor3 = 'Black';
        });

        local TextBoxInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = TextBoxOuter;
        });

        Library:AddToRegistry(TextBoxInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = TextBoxInner;
        });

        local TextBoxContainer = Library:Create('Frame', {
            BackgroundTransparency = 1;
            ClipsDescendants = true;

            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -5, 1, 0);

            ZIndex = 7;
            Parent = TextBoxInner;
        })

        local Box = Library:Create('TextBox', {
            BackgroundTransparency = 1;

            Position = UDim2.fromOffset(0, 0),
            Size = UDim2.fromScale(5, 1),

            ClearTextOnFocus = Info.ClearTextOnFocus or true;
            Font = Enum.Font.Code;
            PlaceholderColor3 = Color3.fromRGB(190, 190, 190);
            PlaceholderText = Info.Placeholder or '';

            Text = Textbox.Value;
            TextColor3 = Library.FontColor;
            TextSize = 14;
            TextStrokeTransparency = 0;
            TextXAlignment = Enum.TextXAlignment.Left;

            ZIndex = 7;
            Parent = TextBoxContainer;
        });

        Library:AddToRegistry(Box, {
            TextColor3 = 'FontColor';
        });

        Library:OnHighlight(TextBoxOuter, TextBoxOuter,
        { BorderColor3 = 'AccentColor' },
        { BorderColor3 = 'Black' }
        );

        function Textbox:SetValue(Text)
            if Info.MaxLength and #Text > Info.MaxLength then
                Text = Text:sub(1, Info.MaxLength);
            end;

            if Textbox.Numeric then
                if (not tonumber(Text)) and Text:len() > 0 then
                    Text = Textbox.Value 
                end
            end

            Textbox.Value = Text;
            Box.Text = Text;

            if Textbox.Changed then
                Textbox.Changed(Textbox.Value)
            end;
        end;

        if Textbox.Finished then
            Box.FocusLost:Connect(function(enter)
                if not enter then return end

                Textbox:SetValue(Box.Text);
                Library:AttemptSave();
            end)
        else 
            Box:GetPropertyChangedSignal('Text'):Connect(function()
                Textbox:SetValue(Box.Text);
                Library:AttemptSave();
            end);
        end

        -- https://devforum.roblox.com/t/how-to-make-textboxes-follow-current-cursor-position/1368429/6

        local function Update()
            local PADDING = 5
            local reveal = TextBoxContainer.AbsoluteSize.X

            if not Box:IsFocused() or Box.TextBounds.X <= reveal - 2 * PADDING then
                -- we aren't focused, or we fit so be normal
                Box.Position = UDim2.new(0, PADDING, 0, 0)
            else
                -- we are focused and don't fit, so adjust position
                local cursor = Box.CursorPosition
                if cursor ~= -1 then
                    -- calculate pixel width of text from start to cursor
                    local subtext = string.sub(Box.Text, 1, cursor-1)
                    local width = TextService:GetTextSize(subtext, Box.TextSize, Box.Font, Vector2.new(math.huge, math.huge)).X

                    -- check if we're inside the box with the cursor
                    local currentCursorPos = Box.Position.X.Offset + width

                    -- adjust if necessary
                    if currentCursorPos < PADDING then
                        Box.Position = UDim2.fromOffset(PADDING-width, 0)
                    elseif currentCursorPos > reveal - PADDING - 1 then
                        Box.Position = UDim2.fromOffset(reveal-width-PADDING-1, 0)
                    end
                end
            end
        end 

        task.spawn(Update)

        Box:GetPropertyChangedSignal('Text'):Connect(Update)
        Box:GetPropertyChangedSignal('CursorPosition'):Connect(Update)
        Box.FocusLost:Connect(Update)
        Box.Focused:Connect(Update)

        function Textbox:OnChanged(Func)
            Textbox.Changed = Func;
            Func(Textbox.Value);
        end

        Textbox.HoverRegion = TextBoxOuter
        Textbox.Container = Container
        for i,v in pairs (BaseAddons) do Textbox[i] = v end

        Groupbox:AddBlank(5);
        Groupbox:Resize();

        Options[Idx] = Textbox;

        return Textbox;
    end

    function Funcs:AddToggle(Idx, Info)

        local Toggle = {
            Enabled = Info.Default or false,
            Name = Info.Text,
            Type = 'Toggle',
        }

        local Groupbox = self
        local Container = Groupbox.Container
        local Holder = Library:Create('Frame', {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 13),
            ZIndex = 5,
            Parent = Container,
        })

        local OuterToggle = Library:Create('Frame', {
            BorderColor3 = Library.Black,
            BorderSizePixel = 1,
            Size = UDim2.new(0, 13, 0, 13),
            Position = UDim2.new(0, 0, 0, 0),
            ZIndex = 5;
            Parent = Holder,
        })

        Library:AddToRegistry(OuterToggle, {
            BorderColor3 = 'Black',
        })

        local InnerToggle = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor,
            BorderColor3 = Library.OutlineColor,
            BorderMode = Enum.BorderMode.Inset,
            BorderSizePixel = 1,
            Size = UDim2.new(1, 0, 1, 0),
            ZIndex = 6;
            Parent = OuterToggle,
        })

        Library:AddToRegistry(InnerToggle, {
            BackgroundColor3 = 'MainColor',
            BorderColor3 = 'OutlineColor',
        })

        local ToggleName = Library:CreateLabel({
            Position = UDim2.new(0, 19, 0, -1),
            Size = UDim2.new(0, 30, 0, 15),
            Text = Toggle.Name,
            TextSize = 14,
            TextXAlignment = Enum.TextXAlignment.Left,
            AutomaticSize = Enum.AutomaticSize.XY,
            ZIndex = 6;
            Parent = Holder,
        })

        local ToggleRegion = Library:Create('Frame', {
            BackgroundTransparency = 1,
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(0, ToggleName.AbsoluteSize.X + 20, 0, 13),
            ZIndex = 8;
            Parent = Holder,
        })

        local AddonRegion = Library:Create('Frame', {
            Position = UDim2.new(1, -64, 0, 0),
            Size = UDim2.new(0, 60, 0, 13),
            Parent = Holder,
            ZIndex = 8;
            BackgroundTransparency = 1,
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 4),
            FillDirection = Enum.FillDirection.Horizontal,
            HorizontalAlignment = Enum.HorizontalAlignment.Right,
            SortOrder = Enum.SortOrder.LayoutOrder,
            VerticalAlignment = Enum.VerticalAlignment.Center,
            Parent = AddonRegion,
        })

        Library:OnHighlight(ToggleRegion, OuterToggle, 
        {BorderColor3 = 'AccentColor'},
        {BorderColor3 = 'Black'}
        )

        function Toggle:UpdateColors()
            InnerToggle.BackgroundColor3 = Toggle.Enabled and Library.AccentColor or Library.MainColor
            InnerToggle.BorderColor3 = Toggle.Enabled and Library.DarkerAccentColor or Library.OutlineColor

            Library.RegistryMap[InnerToggle].Properties.BackgroundColor3 = Toggle.Enabled and 'AccentColor' or 'MainColor'
            Library.RegistryMap[InnerToggle].Properties.BorderColor3 = Toggle.Enabled and 'DarkerAccentColor' or 'OutlineColor'
        end

        function Toggle:SetValue(State)
            Toggle.Enabled = State
            Toggle:UpdateColors()

            if Toggle.Changed then
                Toggle.Changed(Toggle.Enabled)
            end

            if Toggle.KeybindChanged then
                Toggle.KeybindChanged(Toggle.Enabled)
            end 
        end

        ToggleRegion.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                Toggle:SetValue(not Toggle.Enabled)
                Library:AttemptSave()
            end
        end)

        function Toggle:OnChanged(Func)
            Toggle.Changed = Func;
            Func(Toggle.Enabled);
        end

        function Toggle:KeybindOnChanged(Func)
            Toggle.KeybindChanged = Func;
            Func(Toggle.Enabled);
        end
        Toggle:UpdateColors()

        Toggle.AddonRegion = AddonRegion
        Toggle.HoverRegion = ToggleRegion
        Toggle.Container = Container
        for i,v in pairs (BaseAddons) do Toggle[i] = v end

        Groupbox:AddBlank(5)
        Groupbox:Resize()

        Toggles[Idx] = Toggle;

        return Toggle
    end

    function Funcs:AddSlider(Idx, Info)
        assert(Info.Default and Info.Text and Info.Min and Info.Max and Info.Rounding, 'Bad Slider Data');

        local Slider = {
            Value = Info.Default;
            Min = Info.Min;
            Max = Info.Max;
            Rounding = Info.Rounding;
            MaxSize = 210;
            Type = 'Slider';
        };

        local Groupbox = self;
        local Container = Groupbox.Container;

        local SliderLabel
        if not Info.Compact then
            SliderLabel = Library:CreateLabel({
                Size = UDim2.new(1, 0, 0, 10);
                TextSize = 14;
                Text = Info.Text;
                TextXAlignment = Enum.TextXAlignment.Left;
                TextYAlignment = Enum.TextYAlignment.Bottom;
                ZIndex = 5;
                Parent = Container;
            });

            Groupbox:AddBlank(3);
        end

        local SliderOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black;
            Size = UDim2.new(1, -4, 0, 13);
            ZIndex = 5;
            Parent = Container;
        });

        Library:AddToRegistry(SliderOuter, {
            BorderColor3 = 'Black';
        });

        local SliderInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = SliderOuter;
        });

        Library:AddToRegistry(SliderInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local Fill = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderColor3 = Library.DarkerAccentColor;
            Size = UDim2.new(0, 0, 1, 0);
            ZIndex = 7;
            Parent = SliderInner;
        });

        Library:AddToRegistry(Fill, {
            BackgroundColor3 = 'AccentColor';
            BorderColor3 = 'DarkerAccentColor';
        });

        local HideBorderRight = Library:Create('Frame', {
            BackgroundColor3 = Library.AccentColor;
            BorderSizePixel = 0;
            Position = UDim2.new(1, 0, 0, 0);
            Size = UDim2.new(0, 1, 1, 0);
            ZIndex = 8;
            Parent = Fill;
        });

        Library:AddToRegistry(HideBorderRight, {
            BackgroundColor3 = 'AccentColor';
        });

        local DisplayLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 1, 0);
            TextSize = 14;
            Text = 'Infinite';
            ZIndex = 9;
            Parent = SliderInner;
        });

        Library:OnHighlight(SliderOuter, SliderOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' }
        );

        function Slider:Display()
            local Suffix = Info.Suffix or '';

            if Info.Compact and Info.HideMax or Info.LabelInSlider and Info.HideMax then
                DisplayLabel.Text = Info.SliderText .. ': ' .. Slider.Value .. Suffix
            elseif Info.Compact or Info.LabelInSlider then
                DisplayLabel.Text = string.format('%s/%s', Info.SliderText .. ': ' .. Slider.Value .. Suffix, Slider.Max .. Suffix);
            elseif Info.ValueInLabel and Info.HideMax then
                SliderLabel.Text = string.format('%s', Info.Text .. ': ' .. Slider.Value .. Suffix);
                DisplayLabel.Text = ''
            elseif Info.ValueInLabel then
                SliderLabel.Text = string.format('%s/%s', Info.Text .. ': ' .. Slider.Value .. Suffix, Slider.Max .. Suffix);
                DisplayLabel.Text = ''
            elseif Info.HideMax then
                DisplayLabel.Text = string.format('%s', Slider.Value .. Suffix)
            else
                DisplayLabel.Text = string.format('%s/%s', Slider.Value .. Suffix, Slider.Max .. Suffix);
            end

            local X = math.ceil(Library:MapValue(Slider.Value, Slider.Min, Slider.Max, 0, Slider.MaxSize));
            Fill.Size = UDim2.new(0, X, 1, 0);

            HideBorderRight.Visible = not (X == Slider.MaxSize or X == 0);
        end;

        function Slider:OnChanged(Func)
            Slider.Changed = Func;
            Func(Slider.Value);
        end;

        local function Round(Value)
            if Slider.Rounding == 0 then
                return math.floor(Value);
            end;

            return tonumber(string.format('%.' .. Slider.Rounding .. 'f', Value))
        end;

        function Slider:GetValueFromXOffset(X)
            return Round(Library:MapValue(X, 0, Slider.MaxSize, Slider.Min, Slider.Max));
        end;

        function Slider:SetValue(Str)
            local Num = tonumber(Str);

            if (not Num) then
                return;
            end;

            Num = math.clamp(Num, Slider.Min, Slider.Max);

            Slider.Value = Num;
            Slider:Display();

            if Slider.Changed then
                Slider.Changed(Slider.Value)
            end;
        end;

        SliderInner.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                local mPos = Mouse.X;
                local gPos = Fill.Size.X.Offset;
                local Diff = mPos - (Fill.AbsolutePosition.X + gPos);

                while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    local nMPos = Mouse.X;
                    local nX = math.clamp(gPos + (nMPos - mPos) + Diff, 0, Slider.MaxSize);

                    local nValue = Slider:GetValueFromXOffset(nX);
                    local OldValue = Slider.Value;
                    Slider.Value = nValue;

                    Slider:Display();

                    if nValue ~= OldValue and Slider.Changed then
                        Slider.Changed(Slider.Value)
                    end;

                    RenderStepped:Wait();
                end;

                Library:AttemptSave();
            end;
        end);

        Slider:Display();

        Slider.HoverRegion = SliderOuter
        Slider.Container = Container
        for i,v in pairs (BaseAddons) do Slider[i] = v end

        Groupbox:AddBlank(Info.BlankSize or 6);
        Groupbox:Resize();

        Options[Idx] = Slider;

        return Slider;
    end

    function Funcs:AddDropdown(Idx, Info)
        assert(Info.Text and Info.Values, 'Bad Dropdown Data');

        local Dropdown = {
            Values = Info.Values;
            Value = Info.Multi and {};
            Multi = Info.Multi;
            Type = 'Dropdown';
        };

        local Groupbox = self;
        local Container = Groupbox.Container;

        local RelativeOffset = 0;

        if not Info.Compact then
            local DropdownLabel = Library:CreateLabel({
                Size = UDim2.new(1, 0, 0, 10);
                TextSize = 14;
                Text = Info.Text;
                TextXAlignment = Enum.TextXAlignment.Left;
                TextYAlignment = Enum.TextYAlignment.Bottom;
                ZIndex = 5;
                Parent = Container;
            });

            Groupbox:AddBlank(3);
        end

        for _, Element in next, Container:GetChildren() do
            if not Element:IsA('UIListLayout') then
                RelativeOffset = RelativeOffset + Element.Size.Y.Offset;
            end;
        end;

        local DropdownOuter = Library:Create('Frame', {
            BorderColor3 = Library.Black;
            Size = UDim2.new(1, -4, 0, 20);
            ZIndex = 5;
            Parent = Container;
        });

        Library:AddToRegistry(DropdownOuter, {
            BorderColor3 = 'Black';
        });

        local DropdownInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 6;
            Parent = DropdownOuter;
        });

        Library:AddToRegistry(DropdownInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        Library:Create('UIGradient', {
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 212, 212))
            });
            Rotation = 90;
            Parent = DropdownInner;
        });

        local DropdownArrow = Library:Create('ImageLabel', {
            AnchorPoint = Vector2.new(0, 0.5);
            BackgroundTransparency = 1;
            Position = UDim2.new(1, -16, 0.5, 0);
            Size = UDim2.new(0, 12, 0, 12);
            Image = 'http://www.roblox.com/asset/?id=6282522798';
            ZIndex = 7;
            Parent = DropdownInner;
        });

        local ItemList = Library:CreateLabel({
            Position = UDim2.new(0, 5, 0, 0);
            Size = UDim2.new(1, -18, 1, 0);
            TextSize = 14;
            Text = '--';
            TextXAlignment = Enum.TextXAlignment.Left;
            TextWrapped = true;
            ZIndex = 7;
            Parent = DropdownInner;
        });

        Library:OnHighlight(DropdownOuter, DropdownOuter,
            { BorderColor3 = 'AccentColor' },
            { BorderColor3 = 'Black' }
        );

        local MAX_DROPDOWN_ITEMS = 8;

        local ListOuter = Library:Create('Frame', {
            BorderColor3 = Color3.new(0, 0, 0);
            Position = UDim2.new(0, 4, 0, 20 + RelativeOffset + 1 + 20);
            Size = UDim2.new(1, -8, 0, MAX_DROPDOWN_ITEMS * 20 + 2);
            ZIndex = 20;
            Visible = false;
            Parent = Container.Parent;
        });

        local ListInner = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor;
            BorderColor3 = Library.OutlineColor;
            BorderMode = Enum.BorderMode.Inset;
            BorderSizePixel = 0;
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = ListOuter;
        });

        Library:AddToRegistry(ListInner, {
            BackgroundColor3 = 'MainColor';
            BorderColor3 = 'OutlineColor';
        });

        local Scrolling = Library:Create('ScrollingFrame', {
            BackgroundTransparency = 1;
            CanvasSize = UDim2.new(0, 0, 0, 0);
            Size = UDim2.new(1, 0, 1, 0);
            ZIndex = 21;
            Parent = ListInner;

            TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
            BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',

            ScrollBarThickness = 3,
            ScrollBarImageColor3 = Library.AccentColor, 
        });

        Library:AddToRegistry(Scrolling, {
            ScrollBarImageColor3 = 'AccentColor'
        })

        Library:Create('UIListLayout', {
            Padding = UDim.new(0, 0);
            FillDirection = Enum.FillDirection.Vertical;
            SortOrder = Enum.SortOrder.LayoutOrder;
            Parent = Scrolling;
        });

        function Dropdown:Display()
            local Values = Dropdown.Values;
            local Str = '';

            if Info.Multi then
                for Idx, Value in next, Values do
                    if Dropdown.Value[Value] then
                        Str = Str .. Value .. ', ';
                    end;
                end;

                Str = Str:sub(1, #Str - 2);
            else
                Str = Dropdown.Value or '';
            end;

            ItemList.Text = (Str == '' and '--' or Str);
        end;

        function Dropdown:GetActiveValues()
            if Info.Multi then
                local T = {};

                for Value, Bool in next, Dropdown.Value do
                    table.insert(T, Value);
                end;

                return T;
            else
                return Dropdown.Value and 1 or 0;
            end;
        end;

        function Dropdown:SetValues()
            local Values = Dropdown.Values;
            local Buttons = {};

            for _, Element in next, Scrolling:GetChildren() do
                if not Element:IsA('UIListLayout') then
                    -- Library:RemoveFromRegistry(Element);
                    Element:Destroy();
                end;
            end;

            local Count = 0;

            for Idx, Value in next, Values do
                local Table = {};

                Count = Count + 1;

                local Button = Library:Create('Frame', {
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.OutlineColor;
                    BorderMode = Enum.BorderMode.Middle;
                    Size = UDim2.new(1, -1, 0, 20);
                    ZIndex = 23;
                    Active = true,
                    Parent = Scrolling;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                    BorderColor3 = 'OutlineColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Size = UDim2.new(1, -6, 1, 0);
                    Position = UDim2.new(0, 6, 0, 0);
                    TextSize = 14;
                    Text = Value;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    ZIndex = 25;
                    Parent = Button;
                });

                Library:OnHighlight(Button, Button,
                    { BorderColor3 = 'AccentColor', ZIndex = 24 },
                    { BorderColor3 = 'OutlineColor', ZIndex = 23 }
                );

                local Selected;

                if Info.Multi then
                    Selected = Dropdown.Value[Value];
                else
                    Selected = Dropdown.Value == Value;
                end;

                function Table:UpdateButton()
                    if Info.Multi then
                        Selected = Dropdown.Value[Value];
                    else
                        Selected = Dropdown.Value == Value;
                    end;

                    ButtonLabel.TextColor3 = Selected and Library.AccentColor or Library.FontColor;
                    Library.RegistryMap[ButtonLabel].Properties.TextColor3 = Selected and 'AccentColor' or 'FontColor';
                end;

                ButtonLabel.InputBegan:Connect(function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                        local Try = not Selected;

                        if Dropdown:GetActiveValues() == 1 and (not Try) and (not Info.AllowNull) then
                            if Dropdown.Changed then
                                Dropdown.Changed(Dropdown.Value)
                            end;
                        else
                            if Info.Multi then
                                Selected = Try;

                                if Selected then
                                    Dropdown.Value[Value] = true;
                                else
                                    Dropdown.Value[Value] = nil;
                                end;
                            else
                                Selected = Try;

                                if Selected then
                                    Dropdown.Value = Value;
                                else
                                    Dropdown.Value = nil;
                                end;

                                for _, OtherButton in next, Buttons do
                                    OtherButton:UpdateButton();
                                end;
                            end;

                            Table:UpdateButton();
                            Dropdown:Display();

                            if Dropdown.Changed then
                                Dropdown.Changed(Dropdown.Value)
                            end;

                            Library:AttemptSave();
                        end;
                    end;
                end);

                Table:UpdateButton();
                Dropdown:Display();

                Buttons[Button] = Table;
            end;

            local Y = math.clamp(Count * 20, 0, MAX_DROPDOWN_ITEMS * 20) + 1;
            ListOuter.Size = UDim2.new(1, -8, 0, Y);
            Scrolling.CanvasSize = UDim2.new(0, 0, 0, (Count * 20) + 1);

            -- ListOuter.Size = UDim2.new(1, -8, 0, (#Values * 20) + 2);
        end;

        function Dropdown:OpenDropdown()
            ListOuter.Visible = true;
            Library.OpenedFrames[ListOuter] = true;
            DropdownArrow.Rotation = 180;
        end;

        function Dropdown:CloseDropdown()
            ListOuter.Visible = false;
            Library.OpenedFrames[ListOuter] = nil;
            DropdownArrow.Rotation = 0;
        end;

        function Dropdown:OnChanged(Func)
            Dropdown.Changed = Func;
            Func(Dropdown.Value);
        end;

        function Dropdown:SetValue(Val)
            if Dropdown.Multi then
                local nTable = {};

                for Value, Bool in next, Val do
                    if table.find(Dropdown.Values, Value) then
                        nTable[Value] = true
                    end;
                end;

                Dropdown.Value = nTable;
            else
                if (not Val) then
                    Dropdown.Value = nil;
                elseif table.find(Dropdown.Values, Val) then
                    Dropdown.Value = Val;
                end;
            end;

            Dropdown:SetValues();
            Dropdown:Display();

            if Dropdown.Changed then Dropdown.Changed(Dropdown.Value) end
        end;

        DropdownOuter.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                if ListOuter.Visible then
                    Dropdown:CloseDropdown();
                else
                    Dropdown:OpenDropdown();
                end;
            end;
        end);

        Library:GiveSignal(UIS.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                local AbsPos, AbsSize = ListOuter.AbsolutePosition, ListOuter.AbsoluteSize;

                if Mouse.X < AbsPos.X or Mouse.X > AbsPos.X + AbsSize.X
                    or Mouse.Y < (AbsPos.Y - 20 - 1) or Mouse.Y > AbsPos.Y + AbsSize.Y then

                    Dropdown:CloseDropdown();
                end;
            end;
        end));

        Dropdown:SetValues();
        Dropdown:Display();

        local Defaults = {}

        if type(Info.Default) == 'string' then
            local Idx = table.find(Dropdown.Values, Info.Default)
            if Idx then
                table.insert(Defaults, Idx)
            end
        elseif type(Info.Default) == 'table' then
            for _, Value in next, Info.Default do
                local Idx = table.find(Dropdown.Values, Value)
                if Idx then
                    table.insert(Defaults, Idx)
                end
            end
        elseif type(Info.Default) == 'number' and Dropdown.Values[Info.Default] ~= nil then
            table.insert(Defaults, Info.Default)
        end

        if next(Defaults) then
            for i = 1, #Defaults do
                local Index = Defaults[i]
                if Info.Multi then
                    Dropdown.Value[Dropdown.Values[Index]] = true
                else
                    Dropdown.Value = Dropdown.Values[Index];
                end

                if (not Info.Multi) then break end
            end

            Dropdown:SetValues();
            Dropdown:Display();
        end

        Dropdown.HoverRegion = DropdownOuter
        Dropdown.Container = Container
        for i,v in pairs (BaseAddons) do Dropdown[i] = v end

        Groupbox:AddBlank(Info.BlankSize or 5);
        Groupbox:Resize();

        Options[Idx] = Dropdown;

        return Dropdown;
    end;

    BaseComponents = Funcs
end

function Library:CreateWindow(Info)
    local Window = {
        Title = Info.Title,
        Keybind = Info.Keybind,
        Tabs = {},
    }

    local Outer = Library:Create('Frame',{
        BackgroundColor3 = Library.Black,
        BorderSizePixel = 0,
        AnchorPoint = Info.Centered and Vector2.new(0.5, 0.5) or Vector2.new(0, 0),
        Position = Info.Centered and UDim2.new(0.5, 5, 0.5, 2) or UDim2.new(0, 175, 0, 50),
        Size = UDim2.new(0, 528, 0, 578),
        Parent = ScreenGui,
        ZIndex = 1;
        Visible = Info.AutoShow or false,
    })

    Library:MakeDraggable(Outer, 24)

    local Inner = Library:Create('Frame',{
        BackgroundColor3 = Library.MainColor,
        BorderColor3 = Library.AccentColor,
        BorderMode = Enum.BorderMode.Inset,
        Position = UDim2.new(0, 1, 0, 1),
        Size = UDim2.new(1, -2, 1, -2),
        ZIndex = 1;
        Parent = Outer,
    })

    Library:AddToRegistry(Inner, {
        BackgroundColor3 = 'MainColor',
        BorderColor3 = 'AccentColor',
    })

    local WindowLabel = Library:CreateLabel({
        Size = UDim2.new(1, -20, 0, 24),
        Position = UDim2.new(0, 10, 0, 0),
        Text = Window.Title,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 1;
        Parent = Inner,
    })

    local MainOuter = Library:Create('Frame',{
        BackgroundColor3 = Library.BackgroundColor,
        BorderColor3 = Library.OutlineColor,
        Size = UDim2.new(1, -20, 1, -35),
        Position = UDim2.new(0, 10, 0, 25),
        ZIndex = 1;
        Parent = Inner,
    })

    Library:AddToRegistry(MainOuter, {
        BackgroundColor3 = 'BackgroundColor',
        BorderColor3 = 'OutlineColor',
    })

    local MainInner = Library:Create('Frame', {
        BackgroundColor3 = Library.BackgroundColor;
        BorderColor3 = Color3.new(0, 0, 0);
        BorderMode = Enum.BorderMode.Inset;
        Position = UDim2.new(0, 0, 0, 0);
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 1;
        Parent = MainOuter;
    });

    Library:AddToRegistry(MainInner, {
        BackgroundColor3 = 'BackgroundColor';
    })

    local TabButtonArea = Library:Create('Frame',{
        BackgroundTransparency = 1.000,
        Size = UDim2.new(1, -20, 0, 21),
        Position = UDim2.new(0, 11, 0, 11),
        ZIndex = 1;
        Parent = MainInner,
    })

    Library:Create('UIListLayout', {
        FillDirection = Enum.FillDirection.Horizontal,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Parent = TabButtonArea,
    })

    local TabContainer = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;
        Position = UDim2.new(0, 11, 0, 32);
        Size = UDim2.new(1, -22, 1, -43);
        ZIndex = 2;
        Parent = MainInner;
    });

    Library:AddToRegistry(TabContainer, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'OutlineColor';
    });

    function Window:SetWindowTitle(Title)
        WindowLabel.Text = Title;
    end;

    function Window:AddTab(Name)
        local Tab = {
            Groupboxes = {},
            Tabboxes = {},
        }

        local TabButtonWidth, _ = Library:GetTextBounds(Name, Enum.Font.Code, 16)

        local TabButton = Library:Create('Frame', {
            BackgroundColor3 = Library.BackgroundColor,
            BorderColor3 = Library.OutlineColor,
            Size = UDim2.new(0, TabButtonWidth + 8 + 4, 1, 0),
            ZIndex = 1;
            Parent = TabButtonArea,
        })

        Library:AddToRegistry(TabButton, {
            BackgroundColor3 = 'BackgroundColor',
            BorderColor3 = 'OutlineColor',
        });

        local TabButtonLabel = Library:CreateLabel({
            Size = UDim2.new(1, 0, 1, -1),
            Position = UDim2.new(0, 0, 0, 0),
            Text = Name,
            ZIndex = 1;
            Parent = TabButton,
        })

        local Blocker = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor,
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Size = UDim2.new(1, 0, 0, 1),
            Position = UDim2.new(0, 0, 1, -1),
            ZIndex = 3,
            Parent = TabButton,
        })

        Library:AddToRegistry(Blocker, {
            BackgroundColor3 = 'MainColor',
        });

        local TabFrame = Library:Create('Frame', {
            BackgroundColor3 = Library.MainColor,
            BorderColor3 = Library.OutlineColor,
            Size = UDim2.new(1, 0, 1, 0),
            Visible = false,
            ZIndex = 2;
            Parent = TabContainer,
        })

        Library:AddToRegistry(TabFrame, {
            BackgroundColor3 = 'MainColor',
            BorderColor3 = 'OutlineColor',
        })

        local LeftSide = Library:Create('Frame', {
            BackgroundTransparency = 1,
            Size = UDim2.new(0.5, -15, 0, 471),
            Position = UDim2.new(0, 10, 0, 11),
            ZIndex = 2;
            Parent = TabFrame,
        })

        local RightSide = Library:Create('Frame', {
            BackgroundTransparency = 1,
            Size = UDim2.new(0.5, -15, 0, 471),
            Position = UDim2.new(0.5, 5, 0, 11),
            ZIndex = 2;
            Parent = TabFrame,
        })

        Library:Create('UIListLayout',{
            Padding = UDim.new(0, 11),
            HorizontalAlignment = Enum.HorizontalAlignment.Center,
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = LeftSide,
        })

        Library:Create('UIListLayout',{
            Padding = UDim.new(0, 11),
            HorizontalAlignment = Enum.HorizontalAlignment.Center,
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = RightSide,
        })

        function Tab:HideTab()
            Blocker.BackgroundTransparency = 1
            TabButton.BackgroundColor3 = Library.BackgroundColor
            Library.RegistryMap[TabButton].Properties.BackgroundColor3 = 'BackgroundColor'
            TabFrame.Visible = false
        end

        function Tab:ShowTab()
            for _, Tab in next, Window.Tabs do
                Tab:HideTab()
            end;

            Blocker.BackgroundTransparency = 0
            TabButton.BackgroundColor3 = Library.MainColor
            Library.RegistryMap[TabButton].Properties.BackgroundColor3 = 'MainColor'
            TabFrame.Visible = true
        end;

        function Tab:AddGroupbox(Info)
            local Groupbox = {}

            local BoxOuter = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                Size = UDim2.new(1, -1, 0, 0);
                ZIndex = 2;
                Parent = Info.Side == 1 and LeftSide or RightSide;
            });

            Library:AddToRegistry(BoxOuter, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'OutlineColor';
            });

            local BoxInner = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Color3.new(0, 0, 0);
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.new(1, 0, 1, 0);
                ZIndex = 4;
                Parent = BoxOuter;
            });

            Library:AddToRegistry(BoxInner, {
                BackgroundColor3 = 'BackgroundColor';
            });

            local Highlight = Library:Create('Frame', {
                BackgroundColor3 = Library.AccentColor;
                BorderSizePixel = 0;
                Size = UDim2.new(1, 0, 0, 2);
                ZIndex = 5;
                Parent = BoxInner;
            });

            Library:AddToRegistry(Highlight, {
                BackgroundColor3 = 'AccentColor';
            });

            local GroupboxLabel = Library:CreateLabel({
                Size = UDim2.new(1, 0, 0, 18);
                Position = UDim2.new(0, 4, 0, 2);
                TextSize = 14;
                Text = Info.Name;
                TextXAlignment = Enum.TextXAlignment.Left;
                ZIndex = 5;
                Parent = BoxInner;
            });

            local Container = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 4, 0, 20);
                Size = UDim2.new(1, -4, 1, -20);
                ZIndex = 1;
                Parent = BoxInner;
            });

            Library:Create('UIListLayout', {
                SortOrder = Enum.SortOrder.LayoutOrder;
                Parent = Container;
            });

            function Groupbox:Resize()
                local Size = 0;

                for _, Element in next, Groupbox.Container:GetChildren() do
                    if not Element:IsA('UIListLayout') then
                        Size = Size + Element.Size.Y.Offset;
                    end;
                end;

                BoxOuter.Size = UDim2.new(1, -3, 0, 20 + Size + 2);
            end;

            Groupbox.Container = Container;
            for i,v in pairs (BaseComponents) do Groupbox[i] = v end

            Groupbox:AddBlank(3);
            Groupbox:Resize();

            Tab.Groupboxes[Info.Name] = Groupbox

            return Groupbox
        end

        function Tab:AddLeftGroupbox(Name)
            return Tab:AddGroupbox({ Side = 1; Name = Name; });
        end;

        function Tab:AddRightGroupbox(Name)
            return Tab:AddGroupbox({ Side = 2; Name = Name; });
        end;

        function Tab:AddTabbox(Info)
            local Tabbox = {
                Tabs = {};
            };

            local BoxOuter = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Library.OutlineColor;
                Size = UDim2.new(1, -1, 0, 0);
                ZIndex = 2;
                Parent = Info.Side == 1 and LeftSide or RightSide;
            });

            Library:AddToRegistry(BoxOuter, {
                BackgroundColor3 = 'BackgroundColor';
                BorderColor3 = 'OutlineColor';
            });

            local BoxInner = Library:Create('Frame', {
                BackgroundColor3 = Library.BackgroundColor;
                BorderColor3 = Color3.new(0, 0, 0);
                BorderMode = Enum.BorderMode.Inset;
                Size = UDim2.new(1, 0, 1, 0);
                ZIndex = 4;
                Parent = BoxOuter;
            });

            Library:AddToRegistry(BoxInner, {
                BackgroundColor3 = 'BackgroundColor';
            });

            local Highlight = Library:Create('Frame', {
                BackgroundColor3 = Library.AccentColor;
                BorderSizePixel = 0;
                Size = UDim2.new(1, 0, 0, 2);
                ZIndex = 10;
                Parent = BoxInner;
            });

            Library:AddToRegistry(Highlight, {
                BackgroundColor3 = 'AccentColor';
            });

            local TabboxButtons = Library:Create('Frame', {
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 0, 0, 1);
                Size = UDim2.new(1, 0, 0, 18);
                ZIndex = 5;
                Parent = BoxInner;
            });

            Library:Create('UIListLayout', {
                FillDirection = Enum.FillDirection.Horizontal;
                HorizontalAlignment = Enum.HorizontalAlignment.Left;
                SortOrder = Enum.SortOrder.LayoutOrder;
                Parent = TabboxButtons;
            });

            function Tabbox:AddTab(Name)
                local Tab_ = {};

                local Button = Library:Create('Frame', {
                    BackgroundColor3 = Library.MainColor;
                    BorderColor3 = Library.Black;
                    Size = UDim2.new(0.5, 0, 1, 0);
                    ZIndex = 6;
                    Parent = TabboxButtons;
                });

                Library:AddToRegistry(Button, {
                    BackgroundColor3 = 'MainColor';
                });

                local ButtonLabel = Library:CreateLabel({
                    Size = UDim2.new(1, 0, 1, 0);
                    TextSize = 14;
                    Text = Name;
                    TextXAlignment = Enum.TextXAlignment.Center;
                    ZIndex = 7;
                    Parent = Button;
                });

                local Block = Library:Create('Frame', {
                    BackgroundColor3 = Library.BackgroundColor;
                    BorderSizePixel = 0;
                    Position = UDim2.new(0, 0, 1, 0);
                    Size = UDim2.new(1, 0, 0, 1);
                    Visible = false;
                    ZIndex = 9;
                    Parent = Button;
                });

                Library:AddToRegistry(Block, {
                    BackgroundColor3 = 'BackgroundColor';
                });

                local Container = Library:Create('Frame', {
                    Position = UDim2.new(0, 4, 0, 20);
                    Size = UDim2.new(1, -4, 1, -20);
                    ZIndex = 1;
                    Visible = false;
                    Parent = BoxInner;
                });

                Library:Create('UIListLayout', {
                    FillDirection = Enum.FillDirection.Vertical;
                    SortOrder = Enum.SortOrder.LayoutOrder;
                    Parent = Container;
                });

                function Tab_:Hide()
                    Container.Visible = false;
                    Block.Visible = false;

                    Button.BackgroundColor3 = Library.MainColor;
                    Library.RegistryMap[Button].Properties.BackgroundColor3 = 'MainColor';
                end;

                function Tab_:Show()
                    for _, Tab in next, Tabbox.Tabs do
                        Tab:Hide();
                    end;

                    Container.Visible = true;
                    Block.Visible = true;

                    Button.BackgroundColor3 = Library.BackgroundColor;
                    Library.RegistryMap[Button].Properties.BackgroundColor3 = 'BackgroundColor';
                end;

                function Tab_:Resize()
                    local TabCount = 0;

                    for _, Tab in next, Tabbox.Tabs do
                        TabCount = TabCount +  1;
                    end;

                    for _, Button in next, TabboxButtons:GetChildren() do
                        if not Button:IsA('UIListLayout') then
                            Button.Size = UDim2.new(1 / TabCount, 0, 1, 0);
                        end;
                    end;

                    local Size = 0;

                    for _, Element in next, Tab_.Container:GetChildren() do
                        if not Element:IsA('UIListLayout') then
                            Size = Size + Element.Size.Y.Offset;
                        end;
                    end;

                    if BoxOuter.Size.Y.Offset < 20 + Size + 2 then
                        BoxOuter.Size = UDim2.new(1, -3, 0, 20 + Size + 2);
                    end;
                end;

                Button.InputBegan:Connect(function(Input)
                    if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
                        Tab_:Show();
                    end;
                end);

                Tab_.Container = Container
                Tabbox.Tabs[Name] = Tab_
                for i,v in pairs (BaseComponents) do Tab_[i] = v end

                Tab_:AddBlank(3);
                Tab_:Resize();

                if #TabboxButtons:GetChildren() == 2 then
                    Tab_:Show();
                end;

                return Tab_
            end

            Tab.Tabboxes[Info.Name or ''] = Tabbox;

            return Tabbox;
        end

        function Tab:AddLeftTabbox(Name)
            return Tab:AddTabbox({ Name = Name, Side = 1; });
        end;

        function Tab:AddRightTabbox(Name)
            return Tab:AddTabbox({ Name = Name, Side = 2; });
        end;

        TabButton.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                Tab:ShowTab();
            end;
        end);

        -- This was the first tab added, so we show it by default.
        if #TabContainer:GetChildren() == 1 then
            Tab:ShowTab();
        end;

        Window.Tabs[Name] = Tab
        return Tab
    end
    Library.ToggleKeybind = Window.Keybind

    local ModalElement = Library:Create('TextButton', {
        BackgroundTransparency = 1;
        Size = UDim2.new(0, 0, 0, 0);
        Visible = true;
        Text = '';
        Modal = false;
        Parent = ScreenGui;
    });

    function Library.Toggle()
        Outer.Visible = not Outer.Visible;
        ModalElement.Modal = Outer.Visible;

        local Cursor = Drawing.new('Triangle');
        Cursor.Thickness = 1;
        Cursor.Filled = true;

        while Outer.Visible and ScreenGui.Parent do 
            local mPos = UIS:GetMouseLocation()

            Cursor.Color = Library.AccentColor;
            Cursor.PointA = Vector2.new(mPos.X, mPos.Y);
            Cursor.PointB = Vector2.new(mPos.X, mPos.Y) + Vector2.new(6, 14);
            Cursor.PointC = Vector2.new(mPos.X, mPos.Y) + Vector2.new(-6, 14);

            Cursor.Visible = not UIS.MouseIconEnabled;

            RenderStepped:Wait();
        end;

        Cursor:Remove();
    end

    Library:GiveSignal(UIS.InputBegan:Connect(function(Input, Processed)
        if Input.UserInputType == Enum.UserInputType.Keyboard and Input.KeyCode.Name == Library.ToggleKeybind and not Processed then 
            task.spawn(Library.Toggle)
        end
    end))

    if Info.AutoShow then task.spawn(Library.Toggle) task.spawn(Library.Toggle) end 
    Library.Window = Outer

    return Window
end

do 

    Library.NotificationArea = Library:Create('Frame', {
        BackgroundTransparency = 1.000,
        Size = UDim2.new(0, 1, 0, 1),
        Position = UDim2.new(0, 1, 0, 3),
        Parent = ScreenGui,
    })

    Library:Create('UIListLayout', {
        Padding = UDim.new(0, 4),
        FillDirection = Enum.FillDirection.Vertical,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Parent = Library.NotificationArea,
    })


    local WatermarkOuter = Library:Create('Frame', {
        BorderColor3 = Library.Black,
        Size = UDim2.fromOffset(0,20),
        Position = UDim2.fromOffset(100,20),
        Visible = false,
        ZIndex = 200,
        Parent = ScreenGui,
    })

    local WatermarkInner = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor,
        BorderColor3 = Library.AccentColor,
        BorderMode = Enum.BorderMode.Inset,
        Size = UDim2.fromScale(1,1),
        ZIndex = 201,
        Parent = WatermarkOuter,
    })

    Library:AddToRegistry(WatermarkInner, {
        BackgroundColor3 = 'MainColor',
        BorderColor3 = 'AccentColor',
    })

    local InnerFrame = Library:Create('Frame', {
        BackgroundColor3 = Library.White;
        BorderSizePixel = 0;
        Position = UDim2.new(0, 1, 0, 1);
        Size = UDim2.new(1, -2, 1, -2);
        ZIndex = 202;
        Parent = WatermarkInner;
    });

    local Gradient = Library:Create('UIGradient', {
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
            ColorSequenceKeypoint.new(1, Library.MainColor),
        });
        Rotation = -90;
        Parent = InnerFrame;
    });

    Library:AddToRegistry(Gradient, {
        Color = function()
            return ColorSequence.new({
                ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
                ColorSequenceKeypoint.new(1, Library.MainColor),
            });
        end
    });

    local WatermarkLabel = Library:CreateLabel({
        Position = UDim2.new(0, 5, 0, -2);
        TextSize = 14;
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = 203;
        Parent = InnerFrame;
    })

    local FPS 
    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]

    do
        local Frames = 0

        RunService.RenderStepped:Connect(function()
            Frames = Frames + 1
        end)

        task.spawn(function()
            while wait(1) do
                FPS = Frames
                Frames = 0
            end
        end)
    end

    RunService.RenderStepped:Connect(function()
        if WatermarkOuter.Visible then
            local Text =  Library.WatermarkText .. tostring(FPS) .. " FPS | " .. tostring(math.round(Ping:GetValue())) .. " ms"
            local X, _ = Library:GetTextBounds(Text, Enum.Font.Code, 14);
            WatermarkLabel.Text = Text
            WatermarkOuter.Size = UDim2.fromOffset(X + 15, 20)
            InnerFrame.Size = UDim2.new(1, -2, 1, -2)
            WatermarkLabel.Size = UDim2.fromOffset(X, 20)
        end
    end)

    Library.WatermarkFrame = WatermarkOuter
    Library.WatermarkLabel = WatermarkLabel
    Library.WatermarkText = ''
    Library:MakeDraggable(WatermarkOuter, 20) 


    local KeybindOuter = Library:Create('Frame', {
        AnchorPoint = Vector2.new(0, 0.5);
        BorderColor3 = Library.Black;
        Position = UDim2.new(0, 10, 0.5, 0);
        Size = UDim2.new(0, 210, 0, 20);
        Visible = false;
        ZIndex = 100;
        Parent = ScreenGui;
    });

    local KeybindInner = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 101;
        Parent = KeybindOuter;
    });

    Library:AddToRegistry(KeybindInner, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'OutlineColor';
    });

    local ColorFrame = Library:Create('Frame', {
        BackgroundColor3 = Library.AccentColor;
        BorderSizePixel = 0;
        Size = UDim2.new(1, 0, 0, 2);
        ZIndex = 102;
        Parent = KeybindInner;
    });

    Library:AddToRegistry(ColorFrame, {
        BackgroundColor3 = 'AccentColor';
    });

    local KeybindLabel = Library:CreateLabel({
        Size = UDim2.new(1, 0, 0, 20);
        Position = UDim2.fromOffset(0, 2),
        Text = 'Keybinds';
        ZIndex = 104;
        Parent = KeybindInner;
    });

    local KeybindContainer = Library:Create('Frame', {
        BackgroundTransparency = 1;
        Size = UDim2.new(1, 0, 1, -20);
        Position = UDim2.new(0, 0, 0, 20);
        ZIndex = 1;
        Parent = KeybindInner;
    });

    Library:Create('UIListLayout', {
        FillDirection = Enum.FillDirection.Vertical;
        SortOrder = Enum.SortOrder.LayoutOrder;
        Parent = KeybindContainer;
    });

    Library:Create('UIPadding', {
        PaddingLeft = UDim.new(0, 5),
        Parent = KeybindContainer,
    })

    Library.KeybindFrame = KeybindOuter;
    Library.KeybindContainer = KeybindContainer;
    Library:MakeDraggable(KeybindOuter, 20); 
end

function Library:SetKeybindListVisibility(Bool)
    Library.KeybindFrame.Visible = Bool;
end;

function Library:SetWatermarkVisibility(Bool)
    Library.WatermarkFrame.Visible = Bool;
end;

function Library:SetWatermark(Text)
    local X, Y = Library:GetTextBounds(Text, Enum.Font.Code, 14);
    Library:SetWatermarkVisibility(true)

    Library.WatermarkText = Text;
end; 

function Library:Notify (Text, Info)
    local Text = Text
    if Info and Info.ClickToRemove or false then Text = Text..' (Click to Remove)' end
    local X,Y = Library:GetTextBounds(Text, Enum.Font.Code, 14);


    local NotifyOuter = Library:Create('Frame', {
        BorderColor3 = Library.Black;
        Size = UDim2.new(0, 0, 0, 20);
        ClipsDescendants = true;
        ZIndex = 100;
        Parent = Library.NotificationArea;
    });

    local NotifyInner = Library:Create('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;
        BorderMode = Enum.BorderMode.Inset;
        Size = UDim2.new(1, 0, 1, 0);
        ZIndex = 101;
        Parent = NotifyOuter;
    });

    Library:AddToRegistry(NotifyInner, {
        BackgroundColor3 = 'MainColor',
        BorderColor3 = 'OutlineColor',
    })

    local InnerFrame = Library:Create('Frame', {
        BackgroundColor3 = Library.White;
        BorderSizePixel = 0;
        Position = UDim2.new(0, 1, 0, 1);
        Size = UDim2.new(1, -2, 1, -2);
        ZIndex = 102;
        Parent = NotifyInner;
    });

    Library:Create('UIGradient', {
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(27, 27, 27)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(52, 52, 52))
        });
        Rotation = -90;
        Parent = InnerFrame;
    });

    local NotifyLabel = Library:CreateLabel({
        Position = UDim2.new(0, 4, 0, 0);
        Size = UDim2.new(1, -4, 1, 0);
        Text = Text;
        TextXAlignment = Enum.TextXAlignment.Left;
        TextSize = 14;
        ZIndex = 103;
        Parent = InnerFrame;
    });

    local LeftColor = Library:Create('Frame', {
        BackgroundColor3 = Library.AccentColor;
        BorderSizePixel = 0;
        Position = UDim2.new(0, -1, 0, -1);
        Size = UDim2.new(0, 3, 1, 2);
        ZIndex = 104;
        Parent = NotifyOuter;
    });

    Library:AddToRegistry(LeftColor, {
        BackgroundColor3 = 'AccentColor';
    });

    task.spawn(function()
        if Info and Info.ClickToRemove or false then
            NotifyOuter:TweenSize(UDim2.new(0, X + 8 + 4, 0, 20), 'Out', 'Sine', 0.5, false)
            local Event;
            Event = NotifyOuter.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                    NotifyOuter:TweenSize(UDim2.new(0, 0, 0, 20), 'In', 'Sine', 0.5, false)

                    wait(0.5)

                    NotifyOuter:Remove()
                    Event:Disconnect();
                end
            end);
        else
            NotifyOuter:TweenSize(UDim2.new(0, X + 8 + 4, 0, 20), 'Out', 'Sine', 0.5, false)

            wait(Info and Info.Duration or 5)

            NotifyOuter:TweenSize(UDim2.new(0, 0, 0, 20), 'In', 'Sine', 0.5, false)

            wait(0.5)

            NotifyOuter:Remove()

        end

    end)
end

task.spawn(function() while RenderStepped:wait() do Library:UpdateColorsUsingRegistry() end end)

return Library
